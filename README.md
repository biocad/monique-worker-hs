# monique-worker

## Реализация

### Имя воркера

Прежде всего, у воркера должно быть имя. Его можно реализовать так:
```haskell
exampleAName :: W.WorkerName
exampleAName = W.WorkerName "exampleA"
```

Имя будет использоваться:
- для записи лога;
- для подключения к очереди и к контроллеру;
- для вызова данного воркера из других воркеров.

Имя воркера необходимо:
- экспортировать из вашей библиотеки;
- опубликовать в README.md вашей библиотеки для удобства разворачивания системы.

К выбору имени воркера нужно подходить ответственно.

### Конфиг и результат

Для того, чтобы делать какую-либо полезную работу, воркер должен проеобразовывать конфиг в некоторый результат.
Так как через очередь можно отсылать сообщения только в виде `ByteString`.
Форматом для конвертации в и из `ByteString` мы выбрали `JSON`.
Поэтому конфиг и результат должны быть представителями `ToJSON` и `FromJSON`.

Конфиг и результат необходимо:
- экспортировать из вашей библиотеки (вместе в instance'ами `ToJSON` и `FromJSON`).

### Состояние

В воркере можно хранить какое-либо состояние (к примеру, часто используемые данные, которые не хочется загружать снова и снова).
Состояние реализуется как обычный тип.
Если использовать состояние в воркере не нужно, то в качесте состояния-пустышки можно использовать `()`.

### Логика

Для того, чтобы совершать какую-нибудь полезную работу, воркер должен релализовать функцию со следующим типом:
``` haskell
type Algo a s
  =  WorkerInfo              -- ^ use it to generate errors and call foreign workers
  -> a                       -- ^ config to run algorithm
  -> Stateful s WorkerResult -- ^ return result in StateT monad
```
где:
  * `a` - конфиг вашего воркера, которое вы реализовали;
  * `s` - хранимое состояние контроллера, которое вы реализовали;
  * `WorkerInfo` - дополнительная информация, которая используется для генерации ошибки и вызова удалённого воркера.
    
### Генерация ошибки
Если воркер закончился неудачей, ошибку можно кинуть следующими функциями:
``` haskell
throwWorkerError :: WorkerName -> String -> Stateful s WorkerResult
throwWorkerErrorI :: WorkerInfo -> String -> Stateful s WorkerResult
```

### Генерация результата
Если воркер завершился в штатном режиме, то результатом должен быть `WorkerResult`:
``` haskell
data WorkerResult = WorkerResult { taskResult   :: TaskResult
                                 , userdataList :: [(UType, UData)]
                                 } deriving (Show)
```
где 
``` haskell
data TaskResult  = TaskResult { version :: Int
                              , content :: Value
                              }

type UType = Text
type UData = Value
```
a `Value` - объект JSON (из библиотеки `Data.Aeson`). 

### Примеры
Примеры воркеров можно найти в папке `app`.


## Запуск
Для того, чтобы сделать воркера исполняемым, нужно воспользоваться функцией
```haskell
runApp
  :: FromJSON a
  => WorkerName -- ^ worker name
  -> s          -- ^ initial state
  -> Algo a s   -- ^ algorithm to execute
  -> IO ()
```
где в качестве аргумента передать:
  * реализованное имя воркера (ведь ваша библиотека его экспортирует, правильно?);
  * реализованное начальное состояние;
  * реализованную функцию с типом `Algo a s`.

После того, как будет сгенерирован исполняемый файл воркера, можно будет его запустить с ключом `--help`.
Будет напечатана информация с параметрами, которые нужно передать для запуска воркера.



